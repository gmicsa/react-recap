## React + TypeScript Recap

This cheatsheet provides a quick refresher on common React patterns using TypeScript, including Hooks and recent features.
Generated by Google Gemini 2.5

---

### 1. Function Components

The standard way to create components. Use `.tsx` file extension.

**Typing Props:** Define an `interface` or `type` for props.

```tsx
// Define prop types
interface GreetingProps {
  name: string;
  messageCount?: number; // Optional prop
}

// Method 1: Type props directly (Recommended)
const Greeting = ({ name, messageCount = 0 }: GreetingProps): JSX.Element => {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      {messageCount > 0 && <p>You have {messageCount} messages.</p>}
    </div>
  );
};

// Method 2: Using React.FC (FunctionComponent) 
// Note: Less common now, especially since React 18 removed implicit children.
const GreetingFC: React.FC<GreetingProps> = ({ name, messageCount = 0 }) => {
  // children prop is available if needed, but must be explicitly typed in Props
  return (
    <div>
      <h1>Hello, {name}!</h1>
      {messageCount > 0 && <p>You have {messageCount} messages.</p>}
    </div>
  );
};

export default Greeting;
```

---

### 2. Hooks

Hooks let you use state and other React features without writing a class.

#### a. `useState`

Manages state within a component.

*   **Type Inference:** TypeScript often infers the type from the initial value.
*   **Explicit Typing:** Use generics (`useState<Type>`) when the initial value is `null`, `undefined`, or when the type is a union.

```tsx
import React, { useState } from 'react';

const Counter: React.FC = () => {
  // Type inferred as number
  const [count, setCount] = useState(0);

  // Explicit type needed for null initial value or union types
  const [user, setUser] = useState<{ name: string } | null>(null);

  // Type union example 
  type Status = 'idle' | 'loading' | 'success' | 'error';
  const [status, setStatus] = useState<Status>('idle');

  const increment = () => setCount(prevCount => prevCount + 1);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
      <p>Status: {status}</p>
      <button onClick={() => setUser({ name: 'Alice' })}>Login</button>
      {user && <p>User: {user.name}</p>}
    </div>
  );
};

export default Counter;
```

#### b. `useEffect`

Handles side effects (data fetching, subscriptions, DOM manipulation).

```tsx
import React, { useState, useEffect } from 'react';

interface UserProfileProps {
  userId: number;
}

const UserProfile: React.FC<UserProfileProps> = ({ userId }) => {
  const [userData, setUserData] = useState<{ id: number; name: string } | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    setLoading(true);
    console.log(`Fetching data for user ${userId}`);
    const fetchData = async () => {
      // Replace with actual API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      setUserData({ id: userId, name: `User ${userId}` });
      setLoading(false);
    };

    fetchData();

    // Cleanup function (optional) - runs on unmount or before next effect
    return () => {
      console.log(`Cleaning up effect for user ${userId}`);
      // e.g., cancel fetch request, unsubscribe
    };
  }, [userId]); // Dependency array: re-run effect if userId changes

  if (loading) return <p>Loading...</p>;

  return (
    <div>
      <h2>User Profile</h2>
      {userData ? <p>Name: {userData.name}</p> : <p>No data</p>}
    </div>
  );
};

export default UserProfile;
```

#### c. `useContext`

Provides a way to pass data through the component tree without prop drilling.

*   Type the context value using `createContext<ValueType | null>(defaultValue)`.

```tsx
import React, { createContext, useContext, useState, ReactNode } from 'react';

// Define the context shape
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

// Create context with a default value (or null if no sensible default)
const ThemeContext = createContext<ThemeContextType | null>(null);

// Create a Provider component
interface ThemeProviderProps {
  children: ReactNode;
}

export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');
  const toggleTheme = () => setTheme(prev => (prev === 'light' ? 'dark' : 'light'));

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// Custom hook to use the theme context
export const useTheme = (): ThemeContextType => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

// Example Usage Component
const ThemedButton: React.FC = () => {
  const { theme, toggleTheme } = useTheme();
  const style = {
    background: theme === 'dark' ? '#333' : '#FFF',
    color: theme === 'dark' ? '#FFF' : '#333',
    padding: '10px',
    border: '1px solid #ccc',
    cursor: 'pointer'
  };
  return (
    <button style={style} onClick={toggleTheme}>
      Toggle Theme (Current: {theme})
    </button>
  );
};
```

#### d. `useRef`

Accesses DOM elements directly or stores mutable values that don't trigger re-renders.

*   **DOM Refs:** Type with the specific HTML element type (e.g., `HTMLInputElement`) and initialize with `null`.
*   **Mutable Value Refs:** Type with the value type (e.g., `number`) and provide an initial value.

```tsx
import React, { useRef, useEffect, useState } from 'react';

const RefExample: React.FC = () => {
  // Ref for DOM element
  const inputRef = useRef<HTMLInputElement>(null);

  // Ref for a mutable value (e.g., timer ID, previous value)
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const [count, setCount] = useState(0);

  useEffect(() => {
    // Focus input on mount
    inputRef.current?.focus(); // Use optional chaining ?.

    // Example: Start an interval
    intervalRef.current = setInterval(() => {
      console.log('Interval tick');
    }, 5000);

    // Cleanup interval on unmount
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []); // Empty dependency array means run once on mount

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="Focus on mount" />
      <p>Count: {count}</p>
      <button onClick={() => setCount(c => c + 1)}>Increment</button>
    </div>
  );
};

export default RefExample;
```
*Note:* If you need to manually assign to `.current` (e.g., outside the `ref` prop), you might need to type the ref as mutable: `useRef<HTMLInputElement | null>(null)`.

#### e. `useReducer`

An alternative to `useState` for managing complex state logic.

```tsx
import React, { useReducer } from 'react';

// State type
interface CounterState {
  count: number;
}

// Action types (using discriminated union)
type CounterAction =
  | { type: 'INCREMENT'; payload: number }
  | { type: 'DECREMENT'; payload: number }
  | { type: 'RESET' };

// Initial state
const initialState: CounterState = { count: 0 };

// Reducer function
function reducer(state: CounterState, action: CounterAction): CounterState {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + action.payload };
    case 'DECREMENT':
      return { count: state.count - action.payload };
    case 'RESET':
      return initialState;
    default:
      // Optional: Handle exhaustive check with 'never'
      const exhaustiveCheck: never = action;
      return state; // Or throw new Error('Unhandled action type');
  }
}

const ReducerCounter: React.FC = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT', payload: 1 })}>+1</button>
      <button onClick={() => dispatch({ type: 'DECREMENT', payload: 1 })}>-1</button>
      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>
    </div>
  );
};

export default ReducerCounter;
```

#### f. `useCallback` & `useMemo`

Performance optimizations.

*   `useCallback`: Memoizes functions, preventing unnecessary re-creations.
*   `useMemo`: Memoizes computed values.

```tsx
import React, { useState, useMemo, useCallback } from 'react';

interface Props {
  items: string[];
}

const ItemList: React.FC<{ items: string[]; onItemClick: (item: string) => void }> = React.memo(({ items, onItemClick }) => {
  console.log('Rendering ItemList');
  return (
    <ul>
      {items.map(item => (
        <li key={item} onClick={() => onItemClick(item)}>
          {item}
        </li>
      ))}
    </ul>
  );
});

const MemoizationExample: React.FC<Props> = ({ items }) => {
  const [filter, setFilter] = useState<string>('');

  // useMemo: Memoize the filtered list
  const filteredItems = useMemo(() => {
    console.log('Calculating filtered items');
    return items.filter(item => item.toLowerCase().includes(filter.toLowerCase()));
  }, [items, filter]); // Recompute only if items or filter changes

  // useCallback: Memoize the event handler function
  const handleItemClick = useCallback((item: string) => {
    console.log(`Clicked: ${item}`);
    // If this function depended on component state/props, add them to dependencies
  }, []); // Empty array means function never changes (unless component unmounts)

  return (
    <div>
      <input
        type="text"
        placeholder="Filter items..."
        value={filter}
        onChange={(e: React.ChangeEvent<HTMLInputElement>) => setFilter(e.target.value)}
      />
      <ItemList items={filteredItems} onItemClick={handleItemClick} />
    </div>
  );
};

export default MemoizationExample;
```

---

### 3. Event Handling

Type the event object using specific React event types.

```tsx
import React, { useState } from 'react';

const EventForm: React.FC = () => {
  const [value, setValue] = useState<string>('');

  // Typing the change event for an input element
  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    setValue(event.target.value);
  };

  // Typing the submit event for a form
  const handleSubmit = (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault(); // Prevent default form submission
    console.log('Submitted value:', value);
  };

  // Typing the click event for a button
  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    console.log('Button clicked!', event.clientX, event.clientY);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" value={value} onChange={handleChange} />
      <button type="submit" onClick={handleClick}>Submit</button>
    </form>
  );
};

export default EventForm;
```

---

### 4. Conditional Rendering

Standard JavaScript patterns work directly in JSX.

```tsx
import React from 'react';

interface ConditionalProps {
  isLoggedIn: boolean;
  items?: string[];
}

const ConditionalDisplay: React.FC<ConditionalProps> = ({ isLoggedIn, items }) => {
  return (
    <div>
      {/* Ternary Operator */}
      {isLoggedIn ? <p>Welcome back!</p> : <p>Please log in.</p>}

      {/* Logical AND (&&) for rendering only if true */}
      {isLoggedIn && <button>Logout</button>}

      {/* Conditional rendering based on array length */}
      {items && items.length > 0 ? (
        <ul>
          {items.map(item => <li key={item}>{item}</li>)}
        </ul>
      ) : (
        <p>No items to display.</p>
      )}
    </div>
  );
};

export default ConditionalDisplay;
```

---

### 5. Lists and Keys

Use `.map()` to render lists. Always provide a unique `key` prop.

```tsx
import React from 'react';

interface ListItem {
  id: string | number;
  text: string;
}

interface ListProps {
  items: ListItem[];
}

const MyList: React.FC<ListProps> = ({ items }) => {
  return (
    <ul>
      {items.map((item) => (
        // Key should be stable, unique, and preferably a string or number
        <li key={item.id}>
          {item.text}
        </li>
      ))}
    </ul>
  );
};

export default MyList;
```

---

### 6. Custom Hooks

Extract component logic into reusable functions. Custom hooks must start with `use`.

```tsx
import { useState, useCallback } from 'react';

// Custom hook definition
// Returns a tuple: [booleanValue, toggleFunction]
function useToggle(initialValue: boolean = false): [boolean, () => void] {
  const [value, setValue] = useState<boolean>(initialValue);

  // useCallback ensures toggle function identity is stable if dependencies don't change
  const toggle = useCallback(() => {
    setValue(prevValue => !prevValue);
  }, []); // No dependencies, function never needs to be recreated

  return [value, toggle];
}

// Example Usage Component
const ToggleComponent: React.FC = () => {
  const [isOn, toggleIsOn] = useToggle(false);

  return (
    <div>
      <p>The feature is {isOn ? 'ON' : 'OFF'}</p>
      <button onClick={toggleIsOn}>Toggle</button>
    </div>
  );
};

export default ToggleComponent;
```

---

### 7. Advanced TypeScript & Recent Features

#### a. Utility Types

TypeScript provides utility types useful in React:
*   `Partial<T>`: Makes all properties of T optional.
*   `Required<T>`: Makes all properties of T required.
*   `Readonly<T>`: Makes all properties of T readonly.
*   `Pick<T, K>`: Creates a type by picking specified properties K from T.
*   `Omit<T, K>`: Creates a type by omitting specified properties K from T.
*   `Record<K, T>`: Creates an object type with keys of type K and values of type T.

#### b. `PropsWithChildren`

Utility type to explicitly add `children: ReactNode` to your props interface (less common if `React.FC` isn't used, as `children` can be typed directly).

```tsx
import React, { PropsWithChildren } from 'react';

// Example using PropsWithChildren
type BoxProps = PropsWithChildren<{
  style?: React.CSSProperties;
}>;

const Box: React.FC<BoxProps> = ({ children, style }) => {
  return <div style={style}>{children}</div>;
};

// Equivalent without PropsWithChildren (often preferred)
interface BoxPropsDirect {
  children?: React.ReactNode; // Explicitly define children
  style?: React.CSSProperties;
}

const BoxDirect: React.FC<BoxPropsDirect> = ({ children, style }) => {
   return <div style={style}>{children}</div>;
};
```

#### c. The `use` Hook (React 19+)

A newer hook to read the value of resources like Promises or Context, usable within conditionals and loops (unlike other hooks). It integrates with Suspense.

```tsx
import React, { Suspense, use } from 'react';

// Assume fetchMessage returns a Promise<string>
declare function fetchMessage(): Promise<string>;

// This component will suspend while the promise is pending
const MessageComponent: React.FC<{ messagePromise: Promise<string> }> = ({ messagePromise }) => {
  // 'use' unwraps the promise value once resolved
  const message = use(messagePromise);
  return <p>Message: {message}</p>;
};

// Example Usage
const UseHookExample: React.FC = () => {
  // IMPORTANT: Promises passed from Server Components are stable across re-renders.
  // Promises created in Client Components are recreated on every render, potentially causing infinite loops without memoization.
  // For client-side fetching with 'use', manage the promise state carefully (e.g., with useState + useEffect or a library).
  const messagePromise = fetchMessage(); // In a real app, manage this promise's lifecycle

  return (
    <div>
      <h2>Using the 'use' Hook</h2>
      <Suspense fallback={<p>Loading message...</p>}>
        <MessageComponent messagePromise={messagePromise} />
      </Suspense>
    </div>
  );
};

// NOTE: 'use' must be called inside a Component or another Hook.
// NOTE: In Server Components, prefer async/await over 'use' for data fetching.

export default UseHookExample;

```

#### d. React Server Components (RSC)

A newer architecture allowing components to render on the server, reducing client-side JavaScript. `async`/`await` can be used directly in Server Components for data fetching. This is a larger topic beyond a simple cheatsheet example but important to be aware of.

---

This cheatsheet covers many essential concepts. For more in-depth details, refer to the official React and TypeScript documentation.
